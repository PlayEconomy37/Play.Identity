package main

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"strings"
	"testing"
	"time"

	"github.com/PlayEconomy37/Play.Identity/internal/data"
	"go.mongodb.org/mongo-driver/bson/primitive"
)

// invalidAccessToken is a JWT access token NOT generated by the Identity microservice
const invalidAccessToken = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c"

func TestHealthCheckHandler(t *testing.T) {
	app, cleanup, _ := newTestApplication(t)
	t.Cleanup(cleanup)

	ts := newTestServer(t, app.routes())
	defer ts.Close()

	statusCode, _, resBody := ts.get(t, "/healthcheck", false, "")

	if statusCode != http.StatusOK {
		t.Errorf("want %d; got %d", http.StatusOK, statusCode)
	}

	if !bytes.Contains(resBody, []byte("available")) {
		t.Errorf("want body %q to contain %q", []byte("available"), resBody)
	}
}

func TestRegisterUserHandler(t *testing.T) {
	app, cleanup, mockMailServer := newTestApplication(t)
	t.Cleanup(cleanup)

	ts := newTestServer(t, app.routes())
	defer ts.Close()

	// Create user
	password := "password"
	user := createUser(t, ts, "John Doe", "john@doe.com", password)

	validationTests := []struct {
		testName           string
		name               string
		email              string
		password           string
		wantedStatusCode   int
		wantedResponseBody []byte
	}{
		{"Empty name", "", "john@doe.com", "password", http.StatusUnprocessableEntity, []byte("must be provided")},
		{"Empty email", "John Doe", "", "password", http.StatusUnprocessableEntity, []byte("must be provided")},
		{"Empty password", "John Doe", "john@doe.com", "", http.StatusUnprocessableEntity, []byte("must be provided")},
		{"Name too long", strings.Repeat("a", 501), "john@doe.com", "password", http.StatusUnprocessableEntity, []byte("must not be more than 500 bytes long")},
		{"Invalid email", "John Doe", "john@", "password", http.StatusUnprocessableEntity, []byte("must be a valid email address")},
		{"Password too short", "John Doe", "john@", "short", http.StatusUnprocessableEntity, []byte("must be at least 8 bytes long and no more than 72 bytes long")},
		{"Password too long", "John Doe", "john@", strings.Repeat("a", 73), http.StatusUnprocessableEntity, []byte("must be at least 8 bytes long and no more than 72 bytes long")},
		{"User already exists with given email", user.Name, user.Email, password, http.StatusUnprocessableEntity, []byte("a user with this email address already exists")},
	}

	for _, tt := range validationTests {
		t.Run(tt.testName, func(t *testing.T) {
			body := map[string]any{}
			body["name"] = tt.name
			body["email"] = tt.email
			body["password"] = tt.password

			statusCode, _, resBody := ts.post(t, "/auth/register", body, false, "")

			if statusCode != tt.wantedStatusCode {
				t.Errorf("want %d; got %d", tt.wantedStatusCode, statusCode)
			}

			if !bytes.Contains(resBody, tt.wantedResponseBody) {
				t.Errorf("want body %q to contain %q", resBody, tt.wantedResponseBody)
			}
		})
	}

	// -----------------------------

	malformedJSONTest := struct {
		testName           string
		name               int
		email              string
		password           string
		wantedStatusCode   int
		wantedResponseBody []byte
	}{
		"Malformed JSON",
		6,
		"john@doe.com",
		"password",
		http.StatusBadRequest,
		[]byte("body contains incorrect JSON type for field"),
	}

	body := map[string]any{}
	body["name"] = malformedJSONTest.name
	body["email"] = malformedJSONTest.email
	body["password"] = malformedJSONTest.password

	statusCode, _, resBody := ts.post(t, "/auth/register", body, false, "")

	if statusCode != malformedJSONTest.wantedStatusCode {
		t.Errorf("want %d; got %d", malformedJSONTest.wantedStatusCode, statusCode)
	}

	if !bytes.Contains(resBody, malformedJSONTest.wantedResponseBody) {
		t.Errorf("want body %q to contain %q", resBody, malformedJSONTest.wantedResponseBody)
	}

	// -----------------------------

	unknownKeyTest := struct {
		testName           string
		name               string
		email              string
		invalid            string
		wantedStatusCode   int
		wantedResponseBody []byte
	}{
		"Malformed JSON",
		"John Doe",
		"john@doe.com",
		"password",
		http.StatusBadRequest,
		[]byte("body contains unknown key"),
	}

	body = map[string]any{}
	body["name"] = unknownKeyTest.name
	body["email"] = unknownKeyTest.email
	body["invalid"] = unknownKeyTest.invalid

	statusCode, _, resBody = ts.post(t, "/auth/register", body, false, "")

	if statusCode != unknownKeyTest.wantedStatusCode {
		t.Errorf("want %d; got %d", unknownKeyTest.wantedStatusCode, statusCode)
	}

	if !bytes.Contains(resBody, unknownKeyTest.wantedResponseBody) {
		t.Errorf("want body %q to contain %q", resBody, unknownKeyTest.wantedResponseBody)
	}

	// -----------------------------

	name := "Jane Doe"
	email := "jane@doe.com"
	successTest := struct {
		testName         string
		name             string
		email            string
		password         string
		wantedStatusCode int
	}{
		"Valid submission",
		name,
		email,
		"password",
		http.StatusCreated,
	}

	body = map[string]any{}
	body["name"] = successTest.name
	body["email"] = successTest.email
	body["password"] = successTest.password

	statusCode, _, resBody = ts.post(t, "/auth/register", body, false, "")

	if statusCode != successTest.wantedStatusCode {
		t.Errorf("want %d; got %d", successTest.wantedStatusCode, statusCode)
	}

	// Check JSON response
	var jsonRes struct {
		User data.User
	}

	err := json.Unmarshal(resBody, &jsonRes)
	if err != nil {
		t.Error("Failed to parse json response")
	}

	if jsonRes.User.ID != 3 {
		t.Errorf("want to receive 3 but got %v", jsonRes.User.ID)
	}

	if jsonRes.User.Name != name {
		t.Errorf("want to receive %s but got %s", name, jsonRes.User.Name)
	}

	// Check that 2 emails were sent (1 for the success test and 1 for the user created at the beginning of this test suite)
	emails := mockMailServer.Messages()

	if len(emails) != 2 {
		t.Errorf("want to receive %d emails but got %d", 2, len(emails))
	}

	// Fetch user from database and check that it exists
	fetchedUser, err := app.UsersRepository.GetByEmail(context.Background(), email)
	if err != nil {
		t.Fatal(err)
	}

	if fetchedUser.Name != name {
		t.Errorf("want to receive %s but got %s", name, jsonRes.User.Name)
	}

	// Fetch token from database and check that it exists
	tokens, err := app.TokensRepository.GetAllForUser(context.Background(), data.ScopeActivation, fetchedUser.ID)
	if err != nil {
		t.Fatal(err)
	}

	if tokens[0].UserID != fetchedUser.ID {
		t.Errorf("want to receive %d but got %d", fetchedUser.ID, tokens[0].UserID)
	}
}

func TestCreateActivationTokenHandler(t *testing.T) {
	app, cleanup, mockMailServer := newTestApplication(t)
	t.Cleanup(cleanup)

	ts := newTestServer(t, app.routes())
	defer ts.Close()

	// Create activated user
	activatedUser := createActivatedUser(t, ts, mockMailServer, "John Doe", "john@doe.com", "password")

	validationTests := []struct {
		testName           string
		email              string
		wantedStatusCode   int
		wantedResponseBody []byte
	}{
		{"Empty email", "", http.StatusUnprocessableEntity, []byte("must be provided")},
		{"Invalid email", "john@", http.StatusUnprocessableEntity, []byte("must be a valid email address")},
		{"Inexistent email", "nonexistent@email.com", http.StatusUnprocessableEntity, []byte("no matching email address found")},
		{"User already activated", activatedUser.Email, http.StatusUnprocessableEntity, []byte("user has already been activated")},
	}

	for _, tt := range validationTests {
		t.Run(tt.testName, func(t *testing.T) {
			body := map[string]any{}
			body["email"] = tt.email

			statusCode, _, resBody := ts.post(t, "/auth/tokens/activation", body, false, "")

			if statusCode != tt.wantedStatusCode {
				t.Errorf("want %d; got %d", tt.wantedStatusCode, statusCode)
			}

			if !bytes.Contains(resBody, tt.wantedResponseBody) {
				t.Errorf("want body %q to contain %q", resBody, tt.wantedResponseBody)
			}
		})
	}

	// -----------------------------

	malformedJSONTest := struct {
		testName           string
		email              int
		wantedStatusCode   int
		wantedResponseBody []byte
	}{
		"Malformed JSON",
		6,
		http.StatusBadRequest,
		[]byte("body contains incorrect JSON type for field"),
	}

	body := map[string]any{}
	body["email"] = malformedJSONTest.email

	statusCode, _, resBody := ts.post(t, "/auth/tokens/activation", body, false, "")

	if statusCode != malformedJSONTest.wantedStatusCode {
		t.Errorf("want %d; got %d", malformedJSONTest.wantedStatusCode, statusCode)
	}

	if !bytes.Contains(resBody, malformedJSONTest.wantedResponseBody) {
		t.Errorf("want body %q to contain %q", resBody, malformedJSONTest.wantedResponseBody)
	}

	// -----------------------------

	unknownKeyTest := struct {
		testName           string
		invalid            string
		wantedStatusCode   int
		wantedResponseBody []byte
	}{
		"Malformed JSON",
		"john@doe.com",
		http.StatusBadRequest,
		[]byte("body contains unknown key"),
	}

	body = map[string]any{}
	body["invalid"] = unknownKeyTest.invalid

	statusCode, _, resBody = ts.post(t, "/auth/tokens/activation", body, false, "")

	if statusCode != unknownKeyTest.wantedStatusCode {
		t.Errorf("want %d; got %d", unknownKeyTest.wantedStatusCode, statusCode)
	}

	if !bytes.Contains(resBody, unknownKeyTest.wantedResponseBody) {
		t.Errorf("want body %q to contain %q", resBody, unknownKeyTest.wantedResponseBody)
	}

	// -----------------------------

	// Create second user
	user := createUser(t, ts, "Jane Doe", "jane@doe.com", "password")

	// Run success test
	successTest := struct {
		testName           string
		email              string
		wantedStatusCode   int
		wantedResponseBody []byte
	}{
		"Valid submission",
		user.Email,
		http.StatusAccepted,
		[]byte("an email will be sent to you containing activation instructions"),
	}

	body = map[string]any{}
	body["email"] = successTest.email

	statusCode, _, resBody = ts.post(t, "/auth/tokens/activation", body, false, "")

	if statusCode != successTest.wantedStatusCode {
		t.Errorf("want %d; got %d", successTest.wantedStatusCode, statusCode)
	}

	if !bytes.Contains(resBody, successTest.wantedResponseBody) {
		t.Errorf("want body %q to contain %q", resBody, successTest.wantedResponseBody)
	}

	// Check that an email was sent
	emails := mockMailServer.Messages()

	if len(emails) != 2 {
		t.Errorf("want to receive %d tokens but got %d", 2, len(emails))
	}

	// Fetch tokens from database and check that there are 2 tokens stored
	tokens, err := app.TokensRepository.GetAllForUser(context.Background(), data.ScopeActivation, user.ID)
	if err != nil {
		t.Fatal(err)
	}

	if len(tokens) != 2 {
		t.Errorf("want to receive %d tokens but got %d", 2, len(tokens))
	}
}

func TestActivateUserHandler(t *testing.T) {
	app, cleanup, mockMailServer := newTestApplication(t)
	t.Cleanup(cleanup)

	ts := newTestServer(t, app.routes())
	defer ts.Close()

	// Create user
	user := createUser(t, ts, "John Doe", "john@doe.com", "password")

	// Insert expired activation token into the database
	expiredToken, err := app.TokensRepository.New(
		context.Background(),
		user.ID,
		-24*time.Hour, // Set expiry date to yesterday
		data.ScopeActivation,
		nil,
	)
	if err != nil {
		t.Fatal(err)
	}

	// Check that an email was sent when user was created
	emails := mockMailServer.Messages()

	if len(emails) != 1 {
		t.Errorf("want %d email; got %d", 1, len(emails))
	}

	validationTests := []struct {
		testName           string
		token              string
		wantedStatusCode   int
		wantedResponseBody []byte
	}{
		{"Empty token", "", http.StatusUnprocessableEntity, []byte("must be provided")},
		{"Token too short", strings.Repeat("a", 25), http.StatusUnprocessableEntity, []byte("must be 26 bytes long")},
		{"Token too long", strings.Repeat("a", 27), http.StatusUnprocessableEntity, []byte("must be 26 bytes long")},
		{"Inexistent token", strings.Repeat("a", 26), http.StatusUnprocessableEntity, []byte("invalid or expired activation token")},
		{"Expired token", expiredToken.Plaintext, http.StatusUnprocessableEntity, []byte("invalid or expired activation token")},
	}

	for _, tt := range validationTests {
		t.Run(tt.testName, func(t *testing.T) {
			body := map[string]any{}
			body["token"] = tt.token

			statusCode, _, resBody := ts.put(t, "/auth/users/activate", body, false, "")

			if statusCode != tt.wantedStatusCode {
				t.Errorf("want %d; got %d", tt.wantedStatusCode, statusCode)
			}

			if !bytes.Contains(resBody, tt.wantedResponseBody) {
				t.Errorf("want body %q to contain %q", resBody, tt.wantedResponseBody)
			}
		})
	}

	// -----------------------------

	malformedJSONTest := struct {
		testName           string
		token              int
		wantedStatusCode   int
		wantedResponseBody []byte
	}{
		"Malformed JSON",
		6,
		http.StatusBadRequest,
		[]byte("body contains incorrect JSON type for field"),
	}

	body := map[string]any{}
	body["token"] = malformedJSONTest.token

	statusCode, _, resBody := ts.put(t, "/auth/users/activate", body, false, "")

	if statusCode != malformedJSONTest.wantedStatusCode {
		t.Errorf("want %d; got %d", malformedJSONTest.wantedStatusCode, statusCode)
	}

	if !bytes.Contains(resBody, malformedJSONTest.wantedResponseBody) {
		t.Errorf("want body %q to contain %q", resBody, malformedJSONTest.wantedResponseBody)
	}

	// -----------------------------

	unknownKeyTest := struct {
		testName           string
		invalid            string
		wantedStatusCode   int
		wantedResponseBody []byte
	}{
		"Malformed JSON",
		strings.Repeat("a", 26),
		http.StatusBadRequest,
		[]byte("body contains unknown key"),
	}

	body = map[string]any{}
	body["invalid"] = unknownKeyTest.invalid

	statusCode, _, resBody = ts.put(t, "/auth/users/activate", body, false, "")

	if statusCode != unknownKeyTest.wantedStatusCode {
		t.Errorf("want %d; got %d", unknownKeyTest.wantedStatusCode, statusCode)
	}

	if !bytes.Contains(resBody, unknownKeyTest.wantedResponseBody) {
		t.Errorf("want body %q to contain %q", resBody, unknownKeyTest.wantedResponseBody)
	}

	// -----------------------------

	// Fetch tokens from database and check that there are 2 tokens in total
	tokens, err := app.TokensRepository.GetAllForUser(context.Background(), data.ScopeActivation, user.ID)
	if err != nil {
		t.Fatal(err)
	}

	if len(tokens) != 2 {
		t.Errorf("want %d; got %d", 2, len(tokens))
	}

	// Extract activation token from email
	activationToken := extractActivationTokenFromString(emails[0])

	successTest := struct {
		testName           string
		token              string
		wantedStatusCode   int
		wantedResponseBody []byte
	}{
		"Valid submission",
		activationToken,
		http.StatusOK,
		[]byte("User activated successfully"),
	}

	body = map[string]any{}
	body["token"] = successTest.token

	statusCode, _, resBody = ts.put(t, "/auth/users/activate", body, false, "")

	if statusCode != successTest.wantedStatusCode {
		t.Errorf("want %d; got %d", successTest.wantedStatusCode, statusCode)
	}

	if !bytes.Contains(resBody, successTest.wantedResponseBody) {
		t.Errorf("want body %q to contain %q", resBody, successTest.wantedResponseBody)
	}

	// Fetch tokens from database and check that now there are no tokens stored
	refetchedTokens, err := app.TokensRepository.GetAllForUser(context.Background(), data.ScopeActivation, user.ID)
	if err != nil {
		t.Fatal(err)
	}

	if len(refetchedTokens) != 0 {
		t.Errorf("want %d; got %d", 0, len(refetchedTokens))
	}

	// Fetch user from database and check that it is now activated
	fetchedUser, err := app.UsersRepository.GetByEmail(context.Background(), user.Email)
	if err != nil {
		t.Fatal(err)
	}

	if !fetchedUser.Activated {
		t.Errorf("user should be activated")
	}
}

func TestLoginHandler(t *testing.T) {
	app, cleanup, mockMailServer := newTestApplication(t)
	t.Cleanup(cleanup)

	ts := newTestServer(t, app.routes())
	defer ts.Close()

	// Create user
	password := "password"
	user := createUser(t, ts, "John Doe", "john@doe.com", password)

	validationTests := []struct {
		testName           string
		email              string
		password           string
		wantedStatusCode   int
		wantedResponseBody []byte
	}{
		{"Empty email", "", "password", http.StatusUnprocessableEntity, []byte("must be provided")},
		{"Empty password", "john@doe.com", "", http.StatusUnprocessableEntity, []byte("must be provided")},
		{"Invalid email", "john@", "password", http.StatusUnprocessableEntity, []byte("must be a valid email address")},
		{"Password too short", "john@", "short", http.StatusUnprocessableEntity, []byte("must be at least 8 bytes long and no more than 72 bytes long")},
		{"Password too long", "john@", strings.Repeat("a", 73), http.StatusUnprocessableEntity, []byte("must be at least 8 bytes long and no more than 72 bytes long")},
		{"User does not exist with given credentials", "jane@doe.com", password, http.StatusUnauthorized, []byte("invalid authentication credentials")},
		{"Password does not match", "john@doe.com", fmt.Sprintf("%s123", password), http.StatusUnauthorized, []byte("invalid authentication credentials")},
		{"User not yet activated", "john@doe.com", password, http.StatusUnprocessableEntity, []byte("user is not activated")},
	}

	for _, tt := range validationTests {
		t.Run(tt.testName, func(t *testing.T) {
			body := map[string]any{}
			body["email"] = tt.email
			body["password"] = tt.password

			statusCode, _, resBody := ts.post(t, "/auth/login", body, false, "")

			if statusCode != tt.wantedStatusCode {
				t.Errorf("want %d; got %d", tt.wantedStatusCode, statusCode)
			}

			if !bytes.Contains(resBody, tt.wantedResponseBody) {
				t.Errorf("want body %q to contain %q", resBody, tt.wantedResponseBody)
			}
		})
	}

	// -----------------------------

	malformedJSONTest := struct {
		testName           string
		email              int
		password           string
		wantedStatusCode   int
		wantedResponseBody []byte
	}{
		"Malformed JSON",
		6,
		"password",
		http.StatusBadRequest,
		[]byte("body contains incorrect JSON type for field"),
	}

	body := map[string]any{}
	body["email"] = malformedJSONTest.email
	body["password"] = malformedJSONTest.password

	statusCode, _, resBody := ts.post(t, "/auth/login", body, false, "")

	if statusCode != malformedJSONTest.wantedStatusCode {
		t.Errorf("want %d; got %d", malformedJSONTest.wantedStatusCode, statusCode)
	}

	if !bytes.Contains(resBody, malformedJSONTest.wantedResponseBody) {
		t.Errorf("want body %q to contain %q", resBody, malformedJSONTest.wantedResponseBody)
	}

	// -----------------------------

	unknownKeyTest := struct {
		testName           string
		email              string
		invalid            string
		wantedStatusCode   int
		wantedResponseBody []byte
	}{
		"Malformed JSON",
		"john@doe.com",
		"password",
		http.StatusBadRequest,
		[]byte("body contains unknown key"),
	}

	body = map[string]any{}
	body["email"] = unknownKeyTest.email
	body["invalid"] = unknownKeyTest.invalid

	statusCode, _, resBody = ts.post(t, "/auth/login", body, false, "")

	if statusCode != unknownKeyTest.wantedStatusCode {
		t.Errorf("want %d; got %d", unknownKeyTest.wantedStatusCode, statusCode)
	}

	if !bytes.Contains(resBody, unknownKeyTest.wantedResponseBody) {
		t.Errorf("want body %q to contain %q", resBody, unknownKeyTest.wantedResponseBody)
	}

	// -----------------------------

	// Activate created user
	activateUser(t, ts, mockMailServer.Messages()[0])

	successTest := struct {
		testName         string
		email            string
		password         string
		wantedStatusCode int
	}{
		"Valid submission",
		user.Email,
		password,
		http.StatusOK,
	}

	body = map[string]any{}
	body["email"] = successTest.email
	body["password"] = successTest.password

	statusCode, _, resBody = ts.post(t, "/auth/login", body, false, "")

	if statusCode != successTest.wantedStatusCode {
		t.Errorf("want %d; got %d", successTest.wantedStatusCode, statusCode)
	}

	// Check JSON response
	var jsonRes map[string]any

	err := json.Unmarshal(resBody, &jsonRes)
	if err != nil {
		t.Error("Failed to parse json response")
	}

	// Check that token is valid
	if jsonRes["access_token"] == "" {
		t.Errorf("want to receive an access token")
	}

	tokenParts := strings.Split((jsonRes["access_token"]).(string), ".")

	if len(tokenParts) != 3 {
		t.Errorf("want to have 3 token parts but got %d", len(tokenParts))
	}
}

func TestGetUsersHandler(t *testing.T) {
	app, cleanup, _ := newTestApplication(t)
	t.Cleanup(cleanup)

	ts := newTestServer(t, app.routes())
	defer ts.Close()

	// Seed users
	seedUsers(t, app.UsersRepository, app.PermissionsRepository)
	accessTokenUser2 := loginUser(t, ts, "jane@doe.com", "password")
	accessTokenUser3 := loginUser(t, ts, "mike@doe.com", "password")

	authenticationTests := []struct {
		testName           string
		useAuthHeader      bool
		accessToken        string
		wantedStatusCode   int
		wantedResponseBody []byte
	}{
		{"No Authorization header", false, "", http.StatusUnauthorized, []byte("invalid or missing authentication token")},
		{"Invalid access token", true, "invalid", http.StatusUnauthorized, []byte("invalid or missing authentication token")},
		{"Access token not generated by identity microservice", true, invalidAccessToken, http.StatusUnauthorized, []byte("invalid or missing authentication token")},
		{"User does not have permission - has inventory:read", true, accessTokenUser3, http.StatusForbidden, []byte("your user account doesn't have the necessary permissions to access this resource")},
	}

	for _, tt := range authenticationTests {
		t.Run(tt.testName, func(t *testing.T) {
			statusCode, _, resBody := ts.get(t, "/users", tt.useAuthHeader, tt.accessToken)

			if statusCode != tt.wantedStatusCode {
				t.Errorf("want %d; got %d", tt.wantedStatusCode, statusCode)
			}

			if !bytes.Contains(resBody, tt.wantedResponseBody) {
				t.Errorf("want body %q to contain %q", resBody, tt.wantedResponseBody)
			}
		})
	}

	// -----------------------------

	validationTests := []struct {
		testName           string
		queryString        string
		wantedStatusCode   int
		wantedResponseBody []byte
	}{
		{"Invalid page", "?page=invalid", http.StatusUnprocessableEntity, []byte("must be an integer value")},
		{"Invalid page_size", "?page_size=invalid", http.StatusUnprocessableEntity, []byte("must be an integer value")},
		{"Invalid sort value", "?sort=invalid", http.StatusUnprocessableEntity, []byte("invalid sort value")},
		{"page lower than 0", "?page=-1", http.StatusUnprocessableEntity, []byte("must be greater or equal to 0 and lower or equal to 10 million")},
		{"page greater than 10000000", "?page=10000001", http.StatusUnprocessableEntity, []byte("must be greater or equal to 0 and lower or equal to 10 million")},
		{"page_size lower than 0", "?page_size=-1", http.StatusUnprocessableEntity, []byte("must be greater or equal to 0 and lower or equal to 100")},
		{"page_size greater than 100", "?page_size=101", http.StatusUnprocessableEntity, []byte("must be greater or equal to 0 and lower or equal to 100")},
	}

	for _, tt := range validationTests {
		t.Run(tt.testName, func(t *testing.T) {
			statusCode, _, resBody := ts.get(t, fmt.Sprintf("/users%s", tt.queryString), true, accessTokenUser2)

			if statusCode != tt.wantedStatusCode {
				t.Errorf("want %d; got %d", tt.wantedStatusCode, statusCode)
			}

			if !bytes.Contains(resBody, tt.wantedResponseBody) {
				t.Errorf("want body %q to contain %q", resBody, tt.wantedResponseBody)
			}
		})
	}

	// -----------------------------

	successTests := []struct {
		testName             string
		queryString          string
		wantedStatusCode     int
		expectedTotalRecords int
		expectedCurrentPage  int
		expectedLastPage     int
	}{
		{"No filters set", "", http.StatusOK, 3, 1, 1},
		{"name filter", "?name=doe", http.StatusOK, 3, 1, 1},
		{"name, page and page_size filters (page 1)", "?name=doe&page=1&page_size=2", http.StatusOK, 2, 1, 2},
		{"name, page and page_size filters (page 2)", "?name=doe&page=2&page_size=2", http.StatusOK, 1, 2, 2},
		{"name and sort filters", "?name=doe&sort=-name", http.StatusOK, 3, 1, 1},
	}

	for _, tt := range successTests {
		t.Run(tt.testName, func(t *testing.T) {
			statusCode, _, resBody := ts.get(t, fmt.Sprintf("/users%s", tt.queryString), true, accessTokenUser2)

			if statusCode != tt.wantedStatusCode {
				t.Errorf("want %d; got %d", tt.wantedStatusCode, statusCode)
			}

			var jsonRes map[string]any

			err := json.Unmarshal(resBody, &jsonRes)
			if err != nil {
				t.Error("Failed to parse json response")
			}

			users := (jsonRes["users"]).([]any)

			if tt.testName == "name and sort filters" {
				user0 := (users[0]).(map[string]any)
				if user0["name"] != "Mike Doe" {
					t.Errorf("want to receive Mike Doe but got %s", user0["name"])
				}

				user1 := (users[1]).(map[string]any)
				if user1["name"] != "John Doe" {
					t.Errorf("want to receive John Doe but got %s", user1["name"])
				}

				user2 := (users[2]).(map[string]any)
				if user2["name"] != "Jane Doe" {
					t.Errorf("want to receive Jane Doe but got %s", user2["name"])
				}
			}

			if len(users) != tt.expectedTotalRecords {
				t.Errorf("want to receive %d users but got %d", tt.expectedTotalRecords, len(users))
			}

			metadata := (jsonRes["metadata"]).(map[string]any)

			if metadata["total_records"] == tt.expectedTotalRecords {
				t.Errorf("want total_records to be %d but got %d", tt.expectedTotalRecords, metadata["total_records"])
			}

			if metadata["current_page"] == tt.expectedCurrentPage {
				t.Errorf("want current_page to be %d but got %d", tt.expectedCurrentPage, metadata["current_page"])
			}

			if metadata["last_page"] == tt.expectedLastPage {
				t.Errorf("want last_page to be %d but got %d", tt.expectedLastPage, metadata["last_page"])
			}
		})
	}
}

func TestUpdateUserHandler(t *testing.T) {
	app, cleanup, _ := newTestApplication(t)
	t.Cleanup(cleanup)

	ts := newTestServer(t, app.routes())
	defer ts.Close()

	// Seed users
	seedUsers(t, app.UsersRepository, app.PermissionsRepository)
	accessTokenUser1 := loginUser(t, ts, "john@doe.com", "password")
	accessTokenUser2 := loginUser(t, ts, "jane@doe.com", "password")

	name := "John Doe"
	email := "john@doe.com"
	var gil float64 = 200

	authenticationTests := []struct {
		testName           string
		useAuthHeader      bool
		accessToken        string
		wantedStatusCode   int
		wantedResponseBody []byte
	}{
		{"No Authorization header", false, "", http.StatusUnauthorized, []byte("invalid or missing authentication token")},
		{"Invalid access token", true, "invalid", http.StatusUnauthorized, []byte("invalid or missing authentication token")},
		{"Access token not generated by identity microservice", true, invalidAccessToken, http.StatusUnauthorized, []byte("invalid or missing authentication token")},
		{"User does not have permission - has identity:read", true, accessTokenUser2, http.StatusForbidden, []byte("your user account doesn't have the necessary permissions to access this resource")},
	}

	for _, tt := range authenticationTests {
		t.Run(tt.testName, func(t *testing.T) {
			body := map[string]any{}
			body["name"] = name
			body["email"] = email
			body["gil"] = gil

			statusCode, _, resBody := ts.put(t, "/users/1", body, tt.useAuthHeader, tt.accessToken)

			if statusCode != tt.wantedStatusCode {
				t.Errorf("want %d; got %d", tt.wantedStatusCode, statusCode)
			}

			if !bytes.Contains(resBody, tt.wantedResponseBody) {
				t.Errorf("want body %q to contain %q", resBody, tt.wantedResponseBody)
			}
		})
	}

	// -----------------------------

	tests := []struct {
		testName           string
		idURLParam         string
		name               string
		email              string
		gil                float64
		wantedStatusCode   int
		wantedResponseBody []byte
	}{
		{"Valid submission", "1", name, email, gil, http.StatusOK, []byte("User updated successfully")},
		{"Empty name", "1", "", email, gil, http.StatusUnprocessableEntity, []byte("must be provided")},
		{"Empty email", "1", name, "", gil, http.StatusUnprocessableEntity, []byte("must be provided")},
		{"Invalid gil (below or equal to 0)", "1", name, email, 0, http.StatusUnprocessableEntity, []byte("must be greater than 0")},
		{"Name (too long)", "1", strings.Repeat("a", 501), email, gil, http.StatusUnprocessableEntity, []byte("must not be more than 500 bytes long")},
		{"Invalid email", "1", name, "john@", gil, http.StatusUnprocessableEntity, []byte("must be a valid email address")},
		{"Invalid id URL param (ObjectID)", primitive.NewObjectID().Hex(), name, email, gil, http.StatusNotFound, []byte("The requested resource could not be found")},
		{"Invalid id URL param (uuid)", "73f4fa2d-f134-4351-a14e-a0f0a8541712", name, email, gil, http.StatusNotFound, []byte("The requested resource could not be found")},
		{"Invalid id URL param (id < 0)", "0", name, email, gil, http.StatusNotFound, []byte("The requested resource could not be found")},
	}

	for _, tt := range tests {
		t.Run(tt.testName, func(t *testing.T) {
			body := map[string]any{}
			body["name"] = tt.name
			body["email"] = tt.email
			body["gil"] = tt.gil

			statusCode, _, resBody := ts.put(t, fmt.Sprintf("/users/%s", tt.idURLParam), body, true, accessTokenUser1)

			if statusCode != tt.wantedStatusCode {
				t.Errorf("want %d; got %d", tt.wantedStatusCode, statusCode)
			}

			if !bytes.Contains(resBody, tt.wantedResponseBody) {
				t.Errorf("want body %q to contain %q", resBody, tt.wantedResponseBody)
			}
		})
	}

	// Fetch user to make sure it was updated in the database
	updatedUser := fetchUser(t, app.UsersRepository, 1)

	if updatedUser.Gil != gil {
		t.Errorf("want %f; got %f", gil, updatedUser.Gil)
	}

	if updatedUser.Version != 2 {
		t.Errorf("want %d; got %d", 2, updatedUser.Version)
	}

	// -----------------------------

	malformedJSONTest := struct {
		testName           string
		idURLParam         string
		name               string
		email              string
		gil                string
		wantedStatusCode   int
		wantedResponseBody []byte
	}{
		"Malformed JSON",
		"1",
		name,
		email,
		"invalid",
		http.StatusBadRequest,
		[]byte("body contains incorrect JSON type for field"),
	}

	body := map[string]any{}
	body["name"] = malformedJSONTest.name
	body["email"] = malformedJSONTest.email
	body["gil"] = malformedJSONTest.gil

	statusCode, _, resBody := ts.put(t, fmt.Sprintf("/users/%s", malformedJSONTest.idURLParam), body, true, accessTokenUser1)

	if statusCode != malformedJSONTest.wantedStatusCode {
		t.Errorf("want %d; got %d", malformedJSONTest.wantedStatusCode, statusCode)
	}

	if !bytes.Contains(resBody, malformedJSONTest.wantedResponseBody) {
		t.Errorf("want body %q to contain %q", resBody, malformedJSONTest.wantedResponseBody)
	}

	// -----------------------------

	unknownKeyTest := struct {
		testName           string
		idURLParam         string
		name               string
		description        string
		invalid            float64
		wantedStatusCode   int
		wantedResponseBody []byte
	}{
		"Malformed JSON",
		"1",
		name,
		email,
		5,
		http.StatusBadRequest,
		[]byte("body contains unknown key"),
	}

	body = map[string]any{}
	body["name"] = unknownKeyTest.name
	body["description"] = unknownKeyTest.description
	body["invalid"] = unknownKeyTest.invalid

	statusCode, _, resBody = ts.put(t, fmt.Sprintf("/users/%s", unknownKeyTest.idURLParam), body, true, accessTokenUser1)

	if statusCode != unknownKeyTest.wantedStatusCode {
		t.Errorf("want %d; got %d", unknownKeyTest.wantedStatusCode, statusCode)
	}

	if !bytes.Contains(resBody, unknownKeyTest.wantedResponseBody) {
		t.Errorf("want body %q to contain %q", resBody, unknownKeyTest.wantedResponseBody)
	}
}

func TestDeleteUserHandler(t *testing.T) {
	app, cleanup, _ := newTestApplication(t)
	t.Cleanup(cleanup)

	ts := newTestServer(t, app.routes())
	defer ts.Close()

	// Seed users
	seedUsers(t, app.UsersRepository, app.PermissionsRepository)
	accessTokenUser1 := loginUser(t, ts, "john@doe.com", "password")
	accessTokenUser2 := loginUser(t, ts, "jane@doe.com", "password")

	authenticationTests := []struct {
		testName           string
		useAuthHeader      bool
		accessToken        string
		wantedStatusCode   int
		wantedResponseBody []byte
	}{
		{"No Authorization header", false, "", http.StatusUnauthorized, []byte("invalid or missing authentication token")},
		{"Invalid access token", true, "invalid", http.StatusUnauthorized, []byte("invalid or missing authentication token")},
		{"Access token not generated by identity microservice", true, invalidAccessToken, http.StatusUnauthorized, []byte("invalid or missing authentication token")},
		{"User does not have permission - has identity:read", true, accessTokenUser2, http.StatusForbidden, []byte("your user account doesn't have the necessary permissions to access this resource")},
	}

	for _, tt := range authenticationTests {
		t.Run(tt.testName, func(t *testing.T) {
			statusCode, _, resBody := ts.delete(t, fmt.Sprintf("/users/%s", "1"), tt.useAuthHeader, tt.accessToken)

			if statusCode != tt.wantedStatusCode {
				t.Errorf("want %d; got %d", tt.wantedStatusCode, statusCode)
			}

			if !bytes.Contains(resBody, tt.wantedResponseBody) {
				t.Errorf("want body %q to contain %q", resBody, tt.wantedResponseBody)
			}
		})
	}

	// -----------------------------

	tests := []struct {
		testName           string
		id                 string
		wantedStatusCode   int
		wantedResponseBody []byte
	}{
		{"Valid submission", "2", http.StatusOK, []byte("User deleted successfully")},
		{"Invalid id URL param (ObjectID)", primitive.NewObjectID().Hex(), http.StatusNotFound, []byte("The requested resource could not be found")},
		{"Invalid id URL param (uuid)", "73f4fa2d-f134-4351-a14e-a0f0a8541712", http.StatusNotFound, []byte("The requested resource could not be found")},
		{"Invalid id URL param (id < 0)", "0", http.StatusNotFound, []byte("The requested resource could not be found")},
	}

	for _, tt := range tests {
		t.Run(tt.testName, func(t *testing.T) {
			statusCode, _, resBody := ts.delete(t, fmt.Sprintf("/users/%s", tt.id), true, accessTokenUser1)

			if statusCode != tt.wantedStatusCode {
				t.Errorf("want %d; got %d", tt.wantedStatusCode, statusCode)
			}

			if !bytes.Contains(resBody, tt.wantedResponseBody) {
				t.Errorf("want body %q to contain %q", resBody, tt.wantedResponseBody)
			}
		})
	}

	// Fetch user to make sure it does not exist in the database
	user := fetchUser(t, app.UsersRepository, 2)

	// Zero value of name field
	if user != nil {
		t.Errorf("want %v; got %#v", nil, user)
	}
}
